name: dotnet-upgrade-report

on:
  schedule:
    - cron: '30 08 * * *'
  workflow_dispatch:
    inputs:
      branch:
        description: 'The branch to run the report for.'
        required: false
        type: choice
        options:
          - 'dotnet-vnext'
          - 'dotnet-nightly'
        default: 'dotnet-vnext'

permissions: {}

jobs:
  generate:
    runs-on: ubuntu-latest

    concurrency:
      group: '${{ github.workflow }}-${{ inputs.branch }}'
      cancel-in-progress: false

    env:
      GIST_ID: '2083bcc83f30a5038175e4f31e0fc59f'

    steps:
      - name: Generate report
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          github-token: ${{ secrets.ACCESS_TOKEN }}
          script: |
            const branch = `${{ inputs.branch }}`.trim();
            let defaultBranch = 'dotnet-vnext';

            if (!branch) {
              branch = defaultBranch;
            }

            const checksOfInterest = [
              'code-ql',
              'code-ql (csharp)',
              'code-ql (javascript)',
              'dependency-review',
              'lighthouse',
              'lint',
              'macos-latest',
              'ubuntu-latest',
              'validate-packages',
              'windows-latest',
            ];

            const getFileContents = async (owner, repo, path, ref) => {
              let contents = await github.rest.repos.getContent({
                owner,
                repo,
                path,
                ref,
              });
              if (contents.data.encoding === 'base64') {
                return Buffer.from(contents.data.content, 'base64').toString();
              } else if (contents.data.encoding === 'none') {
                const response = await fetch(contents.data.download_url);
                return await response.text();
              } else {
                throw new Error(`Unexpected encoding for ${path}: ${contents.data.encoding}`);
              }
            };

            let config = JSON.parse(await getFileContents(
              context.repo.owner,
              context.repo.repo,
              '.github/workflow-config.json',
              '${{ github.sha }}'
            ));

            const repos = config.repositories;

            function formatSlug(value) {
              return value.replace('-', '--').replace('_', '__').replace(' ', '_');
            }

            function getBadge(label, message, color, logo) {
              label = formatSlug(label);
              message = formatSlug(message);
              return `https://img.shields.io/badge/${label}-${message}-${color}?logo=${logo}`;
            }

            let latestVersion;

            if (branch === default_Branch) {
              const releasesIndex = await fetch('https://raw.githubusercontent.com/dotnet/core/main/release-notes/releases-index.json');
              const releases = await releasesIndex.json();
              latestVersion = releases['releases-index'][0]['latest-sdk'];
            } else {
              const channel = '8.0.1xx-preview7';
              const quality = 'daily';
              const versionsFile = await fetch(`https://aka.ms/dotnet/${channel}/${quality}/sdk-productVersion.txt`);
              const versions = await versionsFile.text();
              latestVersion = versions.trim();
            }

            const report = [
              '# .NET vNext Upgrade Report',
              '',
              '| Pull Request | SDK Version | Build Status | Conflicts? |',
              '| :----------- | :---------- | :----------- | :--------: |',
            ];

            for (let slug of repos) {
              const [owner, repo] = slug.split('/');
              let head;

              try {
                const response = await octokit.rest.repos.getBranch({
                  owner,
                  repo,
                  branch,
                });
                head = response.data.sha;
              } catch (err) {
                core.debug(`The ${branch} branch of ${slug} does not exist or does not have an open pull request.`);
                continue;
              }

              let base;

              if (branch === defaultBranch) {
                const repository = await github.rest.repos.get({
                  owner,
                  repo,
                });
                base = repository.data.default_branch;
              } else {
                base = 'dotnet-vnext';
              }

              const branchPR = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha: head,
              });
              let pr = branchPR.data.find((pr) => pr.base.ref === base);
              if (!pr) {
                core.debug(`The ${branch} branch of ${slug} does not have an open pull request targeting ${base}.`);
                continue;
              }

              pr = github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr.number,
              });

              const checkStatuses = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: head,
              });

              const statusesOfInterest = checkStatuses.data.check_runs
                .filter((check) => checksOfInterest.includes(check.name))
                .map((check) => check.conclusion);

              let combinedStatus = 'success';

              for (let status of statusesOfInterest) {
                if (status === 'failure') {
                  combinedStatus = 'failure';
                  break;
                } else if (status === 'neutral') {
                  combinedStatus = 'pending';
                }
              }

              const globalJson = JSON.parse(await getFileContents(
                owner,
                repo,
                'global.json',
                branch
              ));
              const sdkVersion = globalJson.sdk.version;

              let lineNumber = -1;
              const globalJsonLines = globalJson.split('n');
              for (let i = 0; i < globalJsonLines.length; i++) {
                const line = globalJsonLines[i];
                if (line.includes(sdkVersion)) {
                  lineNumber = i + 1;
                  break;
                }
              }

              const buildColor = combinedStatus === 'success' ? 'brightgreen' : combinedStatus === 'pending' ? 'yellow' : 'red';
              const buildBadge = getBadge('build', combinedStatus, buildColor, 'github');
              const buildUrl = pr.url;

              const purple = '512BD4';
              const sdkColor = sdkVersion === latestVersion ? purple : 'yellow';
              const sdkBadge = getBadge('SDK', sdkVersion, sdkColor, 'dotnet');
              const sdkUrl = `${{ github.server_url }}/${repo}/blob/${branch}/global.json#L${lineNumber}`;

              const hasConflicts = pr.mergeable_state === 'dirty';
              const conflictsColor = hasConflicts ? 'red' : 'brightgreen';
              const conflictsBadge = getBadge('Conflicts', $hasConflicts ? 'Yes' : 'No', conflictsColor, 'git');
              const conflictsUrl = pr.url;

              report.push(
                `| [${repo}#${pr.number}](${pr.url}) | [![.NET SDK version](${sdkBadge})](${sdkUrl}) | [![Build: ${combinedStatus}](${buildBadge})](${buildUrl}) | [![Merge conflicts?](${conflictsBadge})](${conflictsUrl}) |`
              );
            }

            report.push('');
            report.push('Generated by [GitHub Actions](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})');

            await core.summary.addRaw(report.join('\n')).write();

            if (branch === defaultBranch) {
              const gist = await github.rest.gists.update({
                gist_id: `${process.env.GIST_ID}`,
                files: {
                  'summary.md': {
                    content: report.join('\n'),
                  },
                },
              });
              core.notice(gist.data.html_url);
            }
