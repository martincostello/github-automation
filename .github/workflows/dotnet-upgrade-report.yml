name: dotnet-upgrade-report

on:
  schedule:
    - cron: '30 08 * * *'
  workflow_dispatch:
    inputs:
      branch:
        description: 'The branch to run the report for.'
        required: false
        type: choice
        options:
          - 'dotnet-vnext'
          - 'dotnet-nightly'
        default: 'dotnet-vnext'

permissions: {}

jobs:
  generate:
    runs-on: ubuntu-latest
    concurrency:
      group: '${{ github.workflow }}-${{ inputs.branch }}'
      cancel-in-progress: false

    steps:
      - name: Generate report
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          github-token: ${{ secrets.ACCESS_TOKEN }}
          script: |
            const default_branch = 'dotnet-vnext';
            const branch = `${{ inputs.branch }}`.trim() || default_branch;

            const getFileContents = async (owner, repo, path, ref) => {
              const { data: contents } = await github.rest.repos.getContent({
                owner,
                repo,
                path,
                ref,
              });
              if (contents.encoding === 'base64') {
                return Buffer.from(contents.content, 'base64').toString();
              } else if (contents.encoding === 'none') {
                const response = await fetch(contents.download_url);
                return await response.text();
              } else {
                throw new Error(`Unexpected encoding for ${path}: ${contents.encoding}`);
              }
            };

            let config = JSON.parse(await getFileContents(
              context.repo.owner,
              context.repo.repo,
              '.github/workflow-config.json',
              '${{ github.sha }}'
            ));

            const checksOfInterest = config.checksOfInterest;
            const repos = config.repositories;

            const formatSlug = (value) => {
              return value.replace('-', '--').replace('_', '__').replace(' ', '_');
            };

            const getBadge = (label, message, color, logo) => {
              label = formatSlug(label);
              message = formatSlug(message);
              return `https://img.shields.io/badge/${label}-${message}-${color}?logo=${logo}`;
            };

            let latestVersion;

            if (branch === default_branch) {
              const releasesIndex = await fetch('https://raw.githubusercontent.com/dotnet/core/main/release-notes/releases-index.json');
              const releases = await releasesIndex.json();
              latestVersion = releases['releases-index'][0]['latest-sdk'];
            } else {
              const channel = '8.0.1xx-preview7';
              const quality = 'daily';
              const versionsFile = await fetch(`https://aka.ms/dotnet/${channel}/${quality}/sdk-productVersion.txt`);
              const versions = await versionsFile.text();
              latestVersion = versions.trim();
            }

            const report = [
              '# .NET vNext Upgrade Report',
              '',
              '| Pull Request | SDK Version | Build Status | Conflicts? |',
              '| :----------- | :---------- | :----------- | :--------: |',
            ];

            for (let slug of repos) {
              console.log(`Fetching data for ${slug}.`);

              const [owner, repo] = slug.split('/');
              let commit_sha;
              try {
                const response = await github.rest.repos.getBranch({
                  owner,
                  repo,
                  branch,
                });
                commit_sha = response.data.commit.sha;
              } catch (err) {
                core.debug(`The ${branch} branch of ${slug} does not exist or does not have an open pull request.`);
                continue;
              }

              let base_ref;

              if (branch === default_branch) {
                const { data: repository } = await github.rest.repos.get({
                  owner,
                  repo,
                });
                base_ref = repository.default_branch;
              } else {
                base_ref = 'dotnet-vnext';
              }
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha,
              });
              if (prs.length < 1) {
                continue;
              }
              const pull_for_ref = prs.find((pull) => pull.base.ref === base_ref);
              if (!pull_for_ref) {
                core.debug(`The ${branch} branch of ${slug} does not have an open pull request targeting ${base_ref}.`);
                continue;
              }
              const pull_number = pull_for_ref.number;
              let pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              core.debug(`${owner}/${repo}#${pull_number} mergeable_state: ${pr.data.mergeable_state}.`);

              // Poll for changes if the mergeable state is not yet known if a push just occurred.
              // The first read above will start a background job to re-calcuate the mergeability, but it may not be ready immediately.
              // See https://docs.github.com/en/rest/guides/using-the-rest-api-to-interact-with-your-git-database?apiVersion=2022-11-28#checking-mergeability-of-pull-requests
              // and https://github.com/pullreminders/backlog/issues/42#issuecomment-436412823.
              let pollCount = 0;
              const pollDelay = 5000;
              const timeout = 60000;
              const maxPollCount = 60000 / pollDelay;
              while ((pr.data.mergeable_state === null || pr.data.mergeable_state === 'unknown') && pollCount < maxPollCount) {
                await new Promise((resolve) => setTimeout(resolve, pollDelay));
                pr = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number,
                  // Specify cache headers to make the most of the GitHub API's rate limits.
                  // See https://jamiemagee.co.uk/blog/making-the-most-of-github-rate-limits/.
                  headers: {
                    'If-Modified-Since': pr.headers['Last-Modified'],
                    'If-None-Match': pr.headers['Etag'],
                  },
                });
                core.debug(`${owner}/${repo}#${pull_number} mergeable_state: ${pr.data.mergeable_state}.`);
                pollCount++;
              }

              const pull = pr.data;
              const hasConflicts = pull.mergeable_state === 'dirty';

              const { data: checkStatuses } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: commit_sha,
              });

              const statusesOfInterest = checkStatuses.check_runs
                .filter((check) => checksOfInterest.includes(check.name))
                .map((check) => check.conclusion);

              let combinedStatus = 'success';

              for (let status of statusesOfInterest) {
                if (status === 'failure') {
                  combinedStatus = 'failure';
                  break;
                } else if (status === 'neutral') {
                  combinedStatus = 'pending';
                }
              }

              const globalJsonString = await getFileContents(
                owner,
                repo,
                'global.json',
                branch,
              );
              const globalJson = JSON.parse(globalJsonString);
              const sdkVersion = globalJson.sdk.version;

              let lineNumber = -1;
              const globalJsonLines = globalJsonString.split('\n');
              for (let i = 0; i < globalJsonLines.length; i++) {
                const line = globalJsonLines[i];
                if (line.includes(sdkVersion)) {
                  lineNumber = i + 1;
                  break;
                }
              }

              const buildColor = combinedStatus === 'success' ? 'brightgreen' : combinedStatus === 'pending' ? 'yellow' : 'red';
              const buildBadge = getBadge('build', combinedStatus, buildColor, 'github');
              const buildUrl = pull.html_url;

              const purple = '512BD4';
              const sdkColor = sdkVersion === latestVersion ? purple : 'yellow';
              const sdkBadge = getBadge('SDK', sdkVersion, sdkColor, 'dotnet');
              const sdkUrl = `${{ github.server_url }}/${slug}/blob/${branch}/global.json#L${lineNumber}`;

              const conflictsColor = hasConflicts ? 'red' : 'brightgreen';
              const conflictsBadge = getBadge('Conflicts', hasConflicts ? 'Yes' : 'No', conflictsColor, 'git');
              const conflictsUrl = pull.html_url;

              report.push(
                `| [${slug}#${pull.number}](${pull.html_url}) | [![.NET SDK version](${sdkBadge})](${sdkUrl}) | [![Build: ${combinedStatus}](${buildBadge})](${buildUrl}) | [![Merge conflicts?](${conflictsBadge})](${conflictsUrl}) |`
              );
            }

            report.push('');
            report.push('Generated by [GitHub Actions](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})');

            await core.summary.addRaw(report.join('\n')).write();

            if (branch === default_branch) {
              const { data: gist } = await github.rest.gists.update({
                gist_id: '${{ vars.UPGRADE_REPORT_GIST_ID }}',
                files: {
                  'summary.md': {
                    content: report.join('\n'),
                  },
                },
              });
              core.notice(gist.html_url);
            }
