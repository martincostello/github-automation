name: rebase

on:
  workflow_call:
    inputs:
      branch:
        description: "The branch to rebase."
        required: false
        type: string
        default: "dotnet-vnext"
      repository:
        description: "The repository to rebase."
        required: true
        type: string
      force:
        description: "Whether to rebase even if the branch has no conflicts."
        required: false
        type: boolean
        default: false
      base:
        description: "The branch to rebase against."
        required: false
        type: string
        default: ""
  workflow_dispatch:
    inputs:
      branch:
        description: "The branch to rebase."
        required: false
        type: choice
        options:
          - "dotnet-vnext"
          - "dotnet-nightly"
        default: "dotnet-vnext"
      repository:
        description: "An optional single repository to rebase."
        required: false
        type: string
        default: ""
      force:
        description: "Whether to rebase even if the branch has no conflicts."
        required: false
        type: boolean
        default: false
      base:
        description: "The branch to rebase against."
        required: false
        type: choice
        options:
          - "main"
          - "dotnet-vnext"
        default: "main"

permissions: {}

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_GENERATE_ASPNET_CERTIFICATE: false
  DOTNET_MULTILEVEL_LOOKUP: 0
  DOTNET_NOLOGO: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_SYSTEM_CONSOLE_ALLOW_ANSI_COLOR_REDIRECTION: 1
  FORCE_COLOR: 3
  NUGET_XMLDOC_MODE: skip
  TERM: xterm

jobs:
  get-repos:

    outputs:
      repos: ${{ steps.needs-rebase.outputs.result }}

    permissions: {}

    runs-on: [ ubuntu-latest ]

    steps:

      - name: Get repositories to rebase
        id: get-repos
        shell: pwsh
        run: |
          if (-Not [string]::IsNullOrEmpty("${{ inputs.repository }}")) {
            $repos = @("${{ inputs.repository }}")
          }
          else {
            $response = gh api "repos/${{ github.repository }}/contents/.github/workflow-config.json?ref=${{ github.sha }}" | ConvertFrom-Json
            $repos = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($contents.content)) | ConvertFrom-Json).repositories
          }
          $reposJson = ConvertTo-Json $repos -Compress
          "repos=${reposJson}" >> $env:GITHUB_OUTPUT

      - name: Check if branches need rebasing
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        id: needs-rebase
        with:
          github-token: ${{ secrets.ACCESS_TOKEN }}
          result-encoding: json
          script: |
            const repos = JSON.parse(`${{ steps.get-repos.outputs.repos }}`);
            if (${{ inputs.force }}) {
              return repos;
            }
            const dirtyRepos = [];
            for (let i = 0; i < repos.length; i++) {
              const [ owner, repo ] = repos[i].split('/');
              let commit_sha;
              try {
                const branch = await github.rest.repos.getBranch({
                  owner,
                  repo,
                  branch: '${{ inputs.branch }}',
                });
                commit_sha = branch.data.commit.sha;
              } catch (err) {
                core.debug(`Could not get branch: ${err}`);
                continue;
              }
              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha,
              });
              if (prs.data.length < 1) {
                continue;
              }
              let base_ref = '${{ inputs.base }}';
              if (base_ref === '') {
                const repository = await github.rest.repos.get({
                  owner,
                  repo,
                });
                base_ref = repository.data.default_branch;
              }
              const pull_for_ref = prs.data.find((pull) => pull.base.ref === base_ref);
              if (!pull_for_ref) {
                core.debug(`No pull request found targeting ${base_ref}.`);
                continue;
              }
              const pull_number = pull_for_ref.number;
              let pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              core.debug(`${owner}/${repo}#${pull_number} mergeable_state: ${pr.data.mergeable_state}.`);

              // Poll for changes if the mergeable state is not yet known if a push just occurred.
              // The first read above will start a background job to re-calcuate the mergeability, but it may not be ready immediately.
              // See https://docs.github.com/en/rest/guides/using-the-rest-api-to-interact-with-your-git-database?apiVersion=2022-11-28#checking-mergeability-of-pull-requests
              // and https://github.com/pullreminders/backlog/issues/42#issuecomment-436412823.
              let pollCount = 0;
              const pollDelay = 5000;
              const timeout = 60000;
              const maxPollCount = 60000 / pollDelay;
              while ((pr.data.mergeable_state === null || pr.data.mergeable_state === 'unknown') && pollCount < maxPollCount) {
                await new Promise((resolve) => setTimeout(resolve, pollDelay));
                pr = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number,
                  // Specify cache headers to make the most of the GitHub API's rate limits.
                  // See https://jamiemagee.co.uk/blog/making-the-most-of-github-rate-limits/.
                  headers: {
                    'If-Modified-Since': pr.headers['Last-Modified'],
                    'If-None-Match': pr.headers['Etag'],
                  },
                });
                core.debug(`${owner}/${repo}#${pull_number} mergeable_state: ${pr.data.mergeable_state}.`);
                pollCount++;
              }

              const isDirty = pr.data.mergeable_state === 'dirty';
              if (isDirty) {
                core.notice(`${repos[i]} needs rebasing.`);
                dirtyRepos.push(repos[i]);
              }
            }
            return dirtyRepos;

  build:
    needs: get-repos
    if: ${{ needs.get-repos.outputs.repos != '[]' }}

    permissions:
      contents: read

    runs-on: [ ubuntu-latest ]

    steps:

      - name: Checkout code
        uses: actions/checkout@c85c95e3d7251135ab7dc9ce3241c5835cc595a9 # v3.5.3

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@3447fd6a9f9e57506b15f895c5b76d3b197dc7c2 # v3.2.0

      - name: Build rebaser
        shell: pwsh
        run: dotnet publish ./src/Rebaser/Rebaser.csproj --configuration Release --output ./artifacts --runtime linux-x64 --self-contained true

      - name: Publish artifacts
        uses: actions/upload-artifact@0b7f8abb1508181956e8e162db84b466c27e18ce # v3.1.2
        with:
          name: rebaser
          path: ./artifacts
          if-no-files-found: error

  rebase:
    name: "rebase-${{ matrix.repo }}"
    needs: [ get-repos, build ]
    runs-on: [ ubuntu-latest ]

    concurrency:
      group: "rebase-${{ matrix.repo }}"
      cancel-in-progress: false

    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        repo: ${{ fromJSON(needs.get-repos.outputs.repos) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@c85c95e3d7251135ab7dc9ce3241c5835cc595a9 # v3.5.3
        with:
          repository: ${{ matrix.repo }}
          ref: ${{ inputs.branch }}
          fetch-depth: 0
          token: ${{ secrets.ACCESS_TOKEN }}

      - name: Download artifacts
        uses: actions/download-artifact@9bc31d5ccc31df68ecc42ccf4149144866c47d8a # v3.0.2
        with:
          name: rebaser
          path: ./artifacts

      - name: Rebase ${{ inputs.branch }}
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.ACCESS_TOKEN }}
        run: |
          $repo = "${{ matrix.repo }}"
          $branch = "${{ inputs.branch }}"
          $base = "${{ inputs.base }}"

          if ([string]::IsNullOrEmpty($base)) {
            $base = "main"
          }

          chmod +x ./artifacts/Rebaser
          & ./artifacts/Rebaser "${{ github.workspace }}" $base

          if ($LASTEXITCODE -eq 0) {
            git push --force-with-lease origin $branch
            if ($LASTEXITCODE -eq 0) {
              Write-Output "::notice::Rebased the ${branch} branch of ${repo}."
            }
            else {
              Write-Output "::error::Could not push changes to the ${branch} branch of ${repo}."
            }
          }
          elseif ($LASTEXITCODE -eq 1) {
            Write-Output "::warning::Could not resolve conflicts for the ${branch} branch of ${repo}."
            exit 0
          }
          else {
            Write-Output "::error::Failed to rebase the ${branch} branch of ${repo}. Error code: $LASTEXITCODE."
          }
