name: rebase

on:
  workflow_call:
    inputs:
      branch:
        description: "The branch to rebase."
        required: false
        type: string
        default: "dotnet-vnext"
      repository:
        description: "The repository to rebase."
        required: true
        type: string
      force:
        description: "Whether to rebase even if the branch has no conflicts."
        required: false
        type: boolean
        default: false
  workflow_dispatch:
    inputs:
      branch:
        description: "The branch to rebase."
        required: false
        type: choice
        options:
          - "dotnet-vnext"
        default: "dotnet-vnext"
      repository:
        description: "An optional single repository to rebase."
        required: false
        type: string
        default: ""
      force:
        description: "Whether to rebase even if the branch has no conflicts."
        required: false
        type: boolean
        default: false

permissions: {}

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_GENERATE_ASPNET_CERTIFICATE: false
  DOTNET_MULTILEVEL_LOOKUP: 0
  DOTNET_NOLOGO: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_SYSTEM_CONSOLE_ALLOW_ANSI_COLOR_REDIRECTION: 1
  FORCE_COLOR: 3
  NUGET_XMLDOC_MODE: skip
  TERM: xterm

jobs:
  get-repos:

    outputs:
      repos: ${{ steps.needs-rebase.outputs.result }}

    permissions: {}

    runs-on: [ ubuntu-latest ]

    steps:

      - name: Get repositories to rebase
        id: get-repos
        shell: pwsh
        run: |
          if (-Not [string]::IsNullOrEmpty("${{ inputs.repository }}")) {
            $repos = @("${{ inputs.repository }}")
          }
          else {
            $repos = @(
              "justeattakeaway/ApplePayJSSample",
              "justeattakeaway/httpclient-interception",
              "justeattakeaway/JustEat.StatsD",
              "justeattakeaway/JustSaying",
              "martincostello/adventofcode",
              "martincostello/alexa-london-travel",
              "martincostello/alexa-london-travel-site",
              "martincostello/antiforgery-testing-application-part",
              "martincostello/api",
              "martincostello/apple-fitness-workout-mapper",
              "martincostello/aspnet-core-pseudo-localization",
              "martincostello/browserstack-automate",
              "martincostello/costellobot",
              "martincostello/dependabot-helper",
              "martincostello/dotnet-macos-notarization-example",
              "martincostello/dotnet-minimal-api-integration-testing",
              "martincostello/dotnet-patch-automation-sample",
              "martincostello/dotnet-playwright-tests",
              "martincostello/dotnet-repo-template",
              "martincostello/github-automation",
              "martincostello/home",
              "martincostello/lambda-test-server",
              "martincostello/polly-rate-limiting",
              "martincostello/project-euler",
              "martincostello/Pseudolocalizer",
              "martincostello/SignInWithAppleSample",
              "martincostello/sqllocaldb",
              "martincostello/website",
              "martincostello/xunit-logging"
            )
          }
          $reposJson = ConvertTo-Json $repos -Compress
          "repos=${reposJson}" >> $env:GITHUB_OUTPUT

      - name: Check if branches need rebasing
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        id: needs-rebase
        with:
          github-token: ${{ secrets.ACCESS_TOKEN }}
          result-encoding: json
          script: |
            const repos = JSON.parse(`${{ steps.get-repos.outputs.repos }}`);
            if (${{ inputs.force }}) {
              return repos;
            }
            const dirtyRepos = [];
            for (let i = 0; i < repos.length; i++) {
              const [ owner, repo ] = repos[i].split('/');
              let commit_sha;
              try {
                const branch = await github.rest.repos.getBranch({
                  owner,
                  repo,
                  branch: '${{ inputs.branch }}',
                });
                commit_sha = branch.data.commit.sha;
              } catch (err) {
                core.debug(`Could not get branch: ${err}`);
                return false;
              }
              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha,
              });
              if (prs.data.length < 1) {
                return false;
              }
              const repository = await github.rest.repos.get({
                owner,
                repo,
              });
              const default_branch = repository.data.default_branch;
              const pull_number = prs.data.find((pull) => pull.base.ref === default_branch).number;
              const pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              const isDirty = pr.data.mergeable_state === 'dirty';
              if (isDirty) {
                core.notice(`${repos[i]} needs rebasing.`);
                dirtyRepos.push(repos[i]);
              }
            }
            return dirtyRepos;

  build:
    needs: get-repos
    if: ${{ needs.get-repos.outputs.repos != '[]' }}

    permissions:
      contents: read

    runs-on: [ ubuntu-latest ]

    steps:

      - name: Checkout code
        uses: actions/checkout@c85c95e3d7251135ab7dc9ce3241c5835cc595a9 # v3.5.3

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@3447fd6a9f9e57506b15f895c5b76d3b197dc7c2 # v3.2.0

      - name: Build rebaser
        shell: pwsh
        run: dotnet publish ./src/Rebaser/Rebaser.csproj --configuration Release --output ./artifacts --runtime linux-x64 --self-contained true

      - name: Publish artifacts
        uses: actions/upload-artifact@0b7f8abb1508181956e8e162db84b466c27e18ce # v3.1.2
        with:
          name: rebaser
          path: ./artifacts
          if-no-files-found: error

  rebase:
    name: "rebase-${{ matrix.repo }}"
    needs: [ get-repos, build ]
    runs-on: [ ubuntu-latest ]

    concurrency:
      group: "rebase-${{ matrix.repo }}"
      cancel-in-progress: false

    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        repo: ${{ fromJSON(needs.get-repos.outputs.repos) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@c85c95e3d7251135ab7dc9ce3241c5835cc595a9 # v3.5.3
        with:
          repository: ${{ matrix.repo }}
          ref: ${{ inputs.branch }}
          fetch-depth: 0
          token: ${{ secrets.ACCESS_TOKEN }}

      - name: Download artifacts
        uses: actions/download-artifact@9bc31d5ccc31df68ecc42ccf4149144866c47d8a # v3.0.2
        with:
          name: rebaser
          path: ./artifacts

      - name: Rebase ${{ inputs.branch }}
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.ACCESS_TOKEN }}
        run: |
          $repo = "${{ matrix.repo }}"
          $branch = "${{ inputs.branch }}"

          chmod +x ./artifacts/Rebaser
          & ./artifacts/Rebaser "${{ github.workspace }}"

          if ($LASTEXITCODE -eq 0) {
            git push --force-with-lease origin $branch
            if ($LASTEXITCODE -eq 0) {
              Write-Output "::notice::Rebased the ${branch} branch of ${repo}."
            }
            else {
              Write-Output "::error::Could not push changes to the ${branch} branch of ${repo}."
            }
          }
          elseif ($LASTEXITCODE -eq 1) {
            Write-Output "::warning::Could not resolve conflicts for the ${branch} branch of ${repo}."
            exit 0
          }
          else {
            Write-Output "::error::Failed to rebase the ${branch} branch of ${repo}. Error code: $LASTEXITCODE."
          }
